import { BaseAgent } from '../../core/agents/BaseAgent.js';
import type { AgentDependencies } from '../../core/agents/AgentFactory.js';
import type { Plan, Critique, AIService } from '../../services/ai/AIService.js';
import type { MCPTools } from '../../services/mcp/adapters/index.js';

interface ProtoPayload {
  requirements: string;
  owner?: string;
  repo?: string;
  baseBranch?: string;
  branchStrategy?: 'auto' | 'manual';
  dryRun?: boolean;
  stack?: string;
}

export class ProtoAgent extends BaseAgent {
  readonly type = 'proto';
  private aiService?: AIService;

  constructor(deps?: AgentDependencies) {
    super();
    if (deps?.tools?.aiService) {
      this.aiService = deps.tools.aiService as AIService;
    }
    this.playbook.requiresPlanning = true;
    this.playbook.requiresReflection = true;
  }

  async plan(
    planner: { plan(input: { agent: string; goal: string; context?: unknown }): Promise<Plan> },
    context: unknown
  ): Promise<Plan> {
    const payload = context as ProtoPayload;
    const goal = payload?.requirements || 'scaffold a demo project';
    return planner.plan({
      agent: this.type,
      goal: `Generate an MVP scaffold from these requirements:\n\n${goal}`,
      context: { stack: payload?.stack },
    });
  }

  async reflect(
    reflector: { critique(input: { artifact: unknown; context?: unknown }): Promise<Critique> },
    artifact: unknown
  ): Promise<Critique> {
    return reflector.critique({
      artifact,
      context: { agent: this.type },
    });
  }

  async executeWithTools(tools: MCPTools, plan?: Plan, context?: unknown): Promise<unknown> {
    const payload = context as ProtoPayload;
    if (!payload?.requirements) {
      throw new Error('ProtoAgent requires payload with "requirements" field');
    }

    const artifacts: Array<{ filePath: string; content: string }> = [];

    if (this.aiService) {
      const scaffoldResult = await this.aiService.generateWorkArtifact({
        task: `Generate a working MVP project scaffold based on these requirements. For each file, output the file path and content. Requirements:\n\n${payload.requirements}${payload.stack ? `\n\nPreferred stack: ${payload.stack}` : ''}`,
        context: { plan: plan?.steps.map(s => s.title) },
      });

      const parsed = this.parseScaffoldOutput(scaffoldResult.content);
      artifacts.push(...parsed);
    } else {
      artifacts.push(
        { filePath: 'README.md', content: `# MVP Scaffold\n\nGenerated from: ${payload.requirements.substring(0, 100)}...\n` },
        { filePath: 'package.json', content: JSON.stringify({ name: 'mvp-scaffold', version: '0.1.0', scripts: { start: 'node index.js', test: 'echo "tests"' } }, null, 2) },
        { filePath: 'index.js', content: `// MVP Entry Point\nconsole.log('Hello from Proto scaffold');\n` },
      );
    }

    if (!payload.dryRun && payload.owner && payload.repo && tools.githubMCP) {
      const github = tools.githubMCP;
      const branchName = payload.branchStrategy === 'manual'
        ? payload.baseBranch || 'main'
        : `proto/scaffold-${Date.now()}`;

      try {
        if (payload.branchStrategy !== 'manual') {
          await github.createBranch(payload.owner, payload.repo, branchName, payload.baseBranch || 'main');
        }

        for (const artifact of artifacts) {
          await github.commitFile(
            payload.owner,
            payload.repo,
            branchName,
            artifact.filePath,
            artifact.content,
            `proto: scaffold ${artifact.filePath}`
          );
        }

        let prUrl: string | undefined;
        try {
          const prResult = await github.createPRDraft(
            payload.owner,
            payload.repo,
            `[Proto] MVP scaffold`,
            `Auto-generated by AKIS Proto agent.\n\n## Files\n${artifacts.map(a => `- \`${a.filePath}\``).join('\n')}`,
            branchName,
            payload.baseBranch || 'main'
          );
          prUrl = (prResult as { url?: string })?.url;
        } catch {
          // PR optional
        }

        return {
          ok: true,
          agent: 'proto',
          artifacts: artifacts.map(a => ({ filePath: a.filePath })),
          branch: branchName,
          prUrl,
          metadata: { filesCreated: artifacts.length, committed: true },
        };
      } catch (githubError) {
        console.error(`[ProtoAgent] GitHub operations failed:`, githubError);
        return {
          ok: true,
          agent: 'proto',
          artifacts: artifacts.map(a => ({ filePath: a.filePath, content: a.content })),
          metadata: {
            filesCreated: artifacts.length,
            committed: false,
            githubError: githubError instanceof Error ? githubError.message : String(githubError),
          },
        };
      }
    }

    return {
      ok: true,
      agent: 'proto',
      artifacts: artifacts.map(a => ({ filePath: a.filePath, content: a.content })),
      metadata: { filesCreated: artifacts.length, committed: false },
    };
  }

  async execute(context: unknown): Promise<unknown> {
    const payload = context as ProtoPayload;
    return {
      ok: true,
      agent: 'proto',
      message: 'Proto scaffold generated (no tools available - use executeWithTools for full flow)',
      artifacts: [
        { filePath: 'README.md', content: `# MVP\n\n${payload?.requirements || 'No requirements provided'}` },
      ],
    };
  }

  private parseScaffoldOutput(content: string): Array<{ filePath: string; content: string }> {
    const artifacts: Array<{ filePath: string; content: string }> = [];
    const fileBlocks = content.split(/```(?:\w+)?\s*\n/);

    let currentPath = '';
    for (let i = 0; i < fileBlocks.length; i++) {
      const block = fileBlocks[i];

      const pathMatch = block.match(/(?:file|path):\s*[`"]?([^\s`"]+)[`"]?\s*$/im);
      if (pathMatch) {
        currentPath = pathMatch[1];
        continue;
      }

      if (i > 0 && block.includes('```')) {
        const codeContent = block.split('```')[0].trim();
        if (codeContent && currentPath) {
          artifacts.push({ filePath: currentPath, content: codeContent });
          currentPath = '';
        }
      }
    }

    if (artifacts.length === 0) {
      artifacts.push({
        filePath: 'scaffold-output.md',
        content,
      });
    }

    return artifacts;
  }
}
